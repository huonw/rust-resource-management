<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Learn Rust</title>

    
    <link rel="stylesheet" href="resources/normalize1.36.0.css">
<link rel="stylesheet" href="resources/rustdoc1.36.0.css">
<link rel="stylesheet" href="resources/dark1.36.0.css">
<link rel="stylesheet" href="resources/sliderust.css">
<script src="resources/sliderust.js"></script>


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <h1 class="title">Learn Rust</h1>
    <p><img src="images/rust-logo-512x512-blk-stroke.png" alt="" /></p>
<p>Huon Wilson, 2019-08-02</p>
<!--

70% of security vulnerabilities in Microsoft products were due to the
difficulty humans have writing safe C and C++ code. Rust is a
low-level programming language in the same vein that helps the
computer help us write safe code.

I'm Huon, a software engineer on the platform team of the IA or
stellargraph project, and I've got some experience with Rust, so I'm
going to try to help you take some early steps with it.

-->
<h1 id="my-background" class="section-header"><a href="#my-background">My Background</a></h1>
<ul>
<li>Data61 (last August). Previously: Apple on Swift, Mozilla on Rust</li>
<li>Dabbled in many programming languages</li>
</ul>
<img src="images/commits.png" style="max-width: 1000px;">
<h1 id="your-background" class="section-header"><a href="#your-background">Your Background?</a></h1>
<ul>
<li>Rust</li>
<li><strong>Low-level</strong> <small>(C, C++, assembly)</small></li>
<li><strong>Statically-typed, functional</strong> <small>(Haskell, F#, Scala, OCaml)</small></li>
<li><strong>Statically-typed, object-oriented</strong> <small>(Java, C#, Swift, Scala)</small></li>
<li><strong>Dynamically-typed, scripting</strong> <small>(Javascript, Python, PHP, Ruby, Shell)</small></li>
<li><strong>Other</strong> <small>(TypeScript, Go, Fortran, R, Matlab, SQL, Lisp (Clojure, Common Lisp))</small></li>
</ul>
<h1 id="structure" class="section-header"><a href="#structure">Structure</a></h1><!--

How are we going to get there? There'll be 3 sets of exercises: first Rust's approach to resource management, then

-->
<ul>
<li>⇒ <em>Introduction</em></li>
<li>Resource Management (files, memory, mutation)</li>
<li>Error Handling</li>
<li></li>
</ul>
<p>TODO</p>
<h1 id="interlude-setup" class="section-header"><a href="#interlude-setup">Interlude: Setup</a></h1><!--

Before going forward more, let's get things set up, so that can happen
in parallel and everyone is ready when we get to the first exercise soon.

-->
<p>TODO: fill out repo name</p>
<pre><code class="language-shell">$ git clone https://github.com/huonw/...
$ cd ...
</code></pre>
<pre><code class="language-shell">$ cargo --version
cargo 1.36.0 (c4fcfb725 2019-05-15)
$ cargo run
...
Hello world
</code></pre>
<p><a href="https://rust-lang.org/tools/install">rust-lang.org/tools/install</a></p>
<p>(These slides in <code>slides/</code>)</p>
<h1 id="why-rust" class="section-header"><a href="#why-rust">Why Rust?</a></h1><!--

MSRC seems to be a formal team designed to deal with security
vulnerabilities in Microsoft products, both retroactively and
proactively. They performed an analysis of Microsoft's CVEs, and
found, consistently, 70% of them were caused by memory safety
problems.

Memory safety is a crucial building block for any other form of
correctness, and violations can result in, at bestm a segfault, or at
worst memory corruption and security vulnerabilities.

For low-level and high-performance programming, C and C++ are typical
choices, and are likely the source of most of those vulnerabilities.

It's very difficult to write safe C and C++ at any scale. This is
despite a plethora of tools now available, such as fuzzers and static
analysers, and is true even with the at a mega-corporation like
Microsoft, that now has consistent and strong investments in software
correctness and safety, such as Haskell and the Midori operating
system.

Rust is designed to be able to solve the same problems as C and C++,
but with memory safety by default, and thus reducing the risk of the
majority of those bugs.

-->
<p><img src="images/microsoft-unsafe.png" alt="" /></p>
<div style="text-align: right">
<p>— <a href="https://msrc-blog.microsoft.com/2019/07/16/a-proactive-approach-to-more-secure-code">Microsoft Security Response Center</a></p>
</div>
<h1 id="buzzwords" class="section-header"><a href="#buzzwords">Buzzwords</a></h1><!--

Rust has a lot of good parts, and here's a quick summary of some words
it uses to describe itself.

It has memory safety, and, uniquely, it does this without a garbage
collector, which is how it targets the same problems as C and C++,
so-called "systems programming". It does this through "affine typing",
and also uses this to get some measure of thread safety.

-->
<blockquote>
<p>A language empowering everyone to build reliable and efficient
software. — <a href="https://rust-lang.org">rust-lang.org</a></p>
</blockquote>
<ul>
<li><strong>memory safety</strong>, without a garbage collector</li>
<li><strong>affine typing</strong></li>
</ul>
<h1 id="buzzwords-1" class="section-header"><a href="#buzzwords-1">Buzzwords</a></h1><!--

Plus, it has a pile of nice things that are common in modern
languages, static types with type inference and algebraic data types,
pattern matching, and generics. It also has hygenic macros,
easy-to-use tooling, and good platform support, including Windows.

All in all, can feel a bit like a blend of C or C++, and Haskell or
OCaml: a low-level language with high-level conveniences.

--->
<blockquote>
<p>A language empowering everyone to build reliable and efficient
software. — <a href="https://rust-lang.org">rust-lang.org</a></p>
</blockquote>
<ul>
<li><strong>memory safety</strong>, without a garbage collector</li>
<li><strong>affine typing</strong></li>
</ul>
<!-- -->
<ul>
<li>systems programming language</li>
<li>thread safety (no data races)</li>
<li>no runtime (no garbage collector)</li>
<li>generics</li>
<li>algebraic data types</li>
<li>pattern matching</li>
<li>type inference</li>
<li>nice tooling</li>
<li>good platform support</li>
</ul>
<h1 id="the-project-summarise-a-csv-file" class="section-header"><a href="#the-project-summarise-a-csv-file">The Project: Summarise a CSV file</a></h1><!--

I'm going to try to make this as practical as possible. The goal is to
write a little command-line program that will take in a simple CSV
file of numbers, and summarise the columns.

It might look something like this, where the file has two columns,
with headings "year" and "data", and three rows of data. A
summarisation program could tell us the min, mean and max for each of
them.

-->
<p>example.csv:</p>
<pre><code class="language-csv">year,data
2019,61
2020,62
2021,9999
</code></pre>
<p>Your program (maybe):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
$ <span class="ident">cargo</span> <span class="ident">run</span> <span class="op">-</span><span class="op">-</span><span class="ident">bin</span> <span class="ident">summarise</span><span class="op">-</span><span class="ident">csv</span> <span class="op">-</span><span class="op">-</span> <span class="ident">example</span>.<span class="ident">csv</span>
<span class="ident">year</span>: <span class="ident">min</span> <span class="op">=</span> <span class="number">2019</span>, <span class="ident">mean</span> <span class="op">=</span> <span class="number">2020</span>, <span class="ident">max</span> <span class="op">=</span> <span class="number">2021</span>
<span class="ident">data</span>: <span class="ident">min</span> <span class="op">=</span> <span class="number">61</span>, <span class="ident">mean</span> <span class="op">=</span> <span class="number">3374</span>, <span class="ident">max</span> <span class="op">=</span> <span class="number">9999</span></pre></div>
<h1 id="structure-1" class="section-header"><a href="#structure-1">Structure</a></h1><!--

How are we going to get there? There'll be 3 sets of exercises: first Rust's approach to resource management, then

-->
<ul>
<li>Introduction</li>
<li>⇒ <em>Resource Management (files, memory, mutation)</em></li>
<li>Error Handling</li>
<li></li>
</ul>
<p>TODO</p>
<h1 id="resource-management-good" class="section-header"><a href="#resource-management-good">Resource Management: Good</a></h1>
<p>Lifecycle:</p>
<ul>
<li>create/open</li>
<li>use</li>
<li>...</li>
<li>use</li>
<li>clean-up/close</li>
</ul>
<h1 id="resource-management-good-1" class="section-header"><a href="#resource-management-good-1">Resource Management: Good</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// create the resource</span>
<span class="ident">file</span> <span class="op">=</span> <span class="ident">open</span>(<span class="string">&quot;example.csv&quot;</span>)

<span class="comment">// use it</span>
<span class="ident">read</span>(<span class="ident">file</span>)
<span class="ident">read</span>(<span class="ident">file</span>)

<span class="comment">// clean up after it</span>
<span class="ident">close</span>(<span class="ident">file</span>)</pre></div>
<h1 id="resource-management-bad" class="section-header"><a href="#resource-management-bad">Resource Management: Bad</a></h1>
<p>Having to clean up makes life hard</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">file</span> <span class="op">=</span> <span class="ident">open</span>(<span class="string">&quot;example.csv&quot;</span>)
<span class="ident">read</span>(<span class="ident">file</span>)

<span class="comment">// no clean-up</span></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">file</span> <span class="op">=</span> <span class="ident">open</span>(<span class="string">&quot;example.csv&quot;</span>)
<span class="ident">close</span>(<span class="ident">file</span>)
<span class="comment">// use after clean-up</span>
<span class="ident">read</span>(<span class="ident">file</span>)</pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">file</span> <span class="op">=</span> <span class="ident">open</span>(<span class="string">&quot;example.csv&quot;</span>)
<span class="ident">close</span>(<span class="ident">file</span>)
<span class="comment">// double clean-up</span>
<span class="ident">close</span>(<span class="ident">file</span>)</pre></div>
<h1 id="reading-rust-functions" class="section-header"><a href="#reading-rust-functions">Reading Rust: Functions</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">add</span>(<span class="ident">x</span>: <span class="ident">i32</span>, <span class="ident">y</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">i32</span> {
    <span class="ident">x</span> <span class="op">+</span> <span class="ident">y</span>
}</pre></div>
<ul>
<li><code>fn</code> = function</li>
<li>arguments: <code>&lt;name&gt; : &lt;type&gt;</code></li>
<li>return type <code>-&gt; &lt;type&gt;</code></li>
<li>final expression is return value</li>
<li>integer types: <code>i</code> (signed), <code>u</code> (unsigned) followed by size in bits</li>
</ul>
<h1 id="reading-rust-functions-1" class="section-header"><a href="#reading-rust-functions-1">Reading Rust: Functions</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">add</span>(<span class="number">1</span>, <span class="number">2</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;1 + 2 = {}&quot;</span>, <span class="ident">result</span>);
}</pre></div>
<ul>
<li>no return type = <code>-&gt; ()</code></li>
<li><code>let</code> defines variables/name bindings</li>
<li><code>!</code> = &quot;macro&quot;: <code>println</code> does work at compile time to be
type-safe</li>
<li><code>{}</code> placeholder for value to be formatted</li>
<li><code>;</code> needed to separate statements</li>
</ul>
<h1 id="scopes" class="section-header"><a href="#scopes">Scopes</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">File</span>::<span class="ident">open</span>(<span class="string">&quot;example.csv&quot;</span>).<span class="ident">unwrap</span>();

    <span class="ident">file</span>.<span class="ident">read</span>(...).<span class="ident">unwrap</span>();
} <span class="comment">// automatically closed at end of scope</span></pre></div>
<ul>
<li>always<sup>*</sup> closed</li>
<li>cannot close twice</li>
<li>cannot read after close</li>
</ul>
<p>(<code>unwrap</code> = error &quot;handling'.)</p>
<h1 id="moves" class="section-header"><a href="#moves">Moves</a></h1>
<p>Resources are values, not bindings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>;

<span class="kw">fn</span> <span class="ident">open_file</span>() <span class="op">-&gt;</span> <span class="ident">File</span> {
    <span class="kw">let</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">File</span>::<span class="ident">open</span>(<span class="string">&quot;example.csv&quot;</span>).<span class="ident">unwrap</span>();
    <span class="ident">file</span>
} <span class="comment">// not closed, moved as return value</span>

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">open_file</span>();
    <span class="ident">consume_file</span>(<span class="ident">file</span>);
} <span class="comment">// not closed, moved into `consume_file`</span>

<span class="kw">fn</span> <span class="ident">consume_file</span>(<span class="ident">file</span>: <span class="ident">File</span>) {
    <span class="ident">file</span>.<span class="ident">read</span>(...).<span class="ident">unwrap</span>();
} <span class="comment">// automatically closed at end of scope</span></pre></div>
<h1 id="exercise" class="section-header"><a href="#exercise">Exercise</a></h1>
<p>Open</p>
<p><code class="exercise">src/bin/resource-management.rs</code></p>
<p>Run using <code>cargo run --bin resource-management</code>.</p>
<h1 id="moves-1" class="section-header"><a href="#moves-1">Moves</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">open_file</span>();
    <span class="ident">consume_file</span>(<span class="ident">file</span>); <span class="comment">// A</span>

    <span class="ident">consume_file</span>(<span class="ident">file</span>); <span class="comment">// B</span>

}

<span class="kw">fn</span> <span class="ident">open_file</span>() <span class="op">-&gt;</span> <span class="ident">File</span> { ... }

<span class="kw">fn</span> <span class="ident">consume_file</span>(<span class="ident">file</span>: <span class="ident">File</span>) { ... }</pre></div>
<p>What's going to happen?</p>
<h1 id="moves-2" class="section-header"><a href="#moves-2">Moves</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">open_file</span>();
    <span class="ident">consume_file</span>(<span class="ident">file</span>); <span class="comment">// A</span>
    <span class="comment">//           ---- value moved here</span>
    <span class="ident">consume_file</span>(<span class="ident">file</span>); <span class="comment">// B: ERROR: use of moved value</span>
    <span class="comment">//           ^^^^ value used here after move</span>
}

<span class="kw">fn</span> <span class="ident">open_file</span>() <span class="op">-&gt;</span> <span class="ident">File</span> { ... }

<span class="kw">fn</span> <span class="ident">consume_file</span>(<span class="ident">file</span>: <span class="ident">File</span>) { ... }</pre></div>
<p>What's going to happen? Compile error.</p>
<h1 id="moves-3" class="section-header"><a href="#moves-3">Moves</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">open_file</span>();
    <span class="kw">let</span> <span class="ident">file2</span> <span class="op">=</span> <span class="ident">consume_file</span>(<span class="ident">file</span>); <span class="comment">// A</span>
    <span class="ident">consume_file</span>(<span class="ident">file2</span>); <span class="comment">// B</span>
}

<span class="kw">fn</span> <span class="ident">open_file</span>() <span class="op">-&gt;</span> <span class="ident">File</span> { ... }

<span class="kw">fn</span> <span class="ident">consume_file</span>(<span class="ident">file</span>: <span class="ident">File</span>) <span class="op">-&gt;</span> <span class="ident">File</span> { ... } <span class="comment">// C</span></pre></div>
<h1 id="mut" class="section-header"><a href="#mut"><code>&amp;mut</code></a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">open_file</span>();
    <span class="ident">modify__file</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">file</span>); <span class="comment">// A</span>
    <span class="ident">modify__file</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">file</span>); <span class="comment">// B</span>
}

<span class="kw">fn</span> <span class="ident">open_file</span>() <span class="op">-&gt;</span> <span class="ident">File</span> { ... }

<span class="kw">fn</span> <span class="ident">modify__file</span>(<span class="ident">file</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">File</span>) { ... } <span class="comment">// C</span></pre></div>
<h1 id="moves-more-realistic" class="section-header"><a href="#moves-more-realistic">Moves, more realistic</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">open_file</span>(<span class="string">&quot;data/example.csv&quot;</span>);
    <span class="kw">let</span>  <span class="ident">headings</span> <span class="op">=</span> <span class="ident">read_line</span>(<span class="ident">file</span>); <span class="comment">// A</span>
    <span class="kw">let</span>  <span class="ident">data_line</span> <span class="op">=</span> <span class="ident">read_line</span>(<span class="ident">file</span>); <span class="comment">// B: ERROR</span>
}

<span class="kw">fn</span> <span class="ident">open_file</span>(<span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="ident">File</span> { ... }

<span class="kw">fn</span> <span class="ident">read_line</span>(<span class="kw-2">mut</span> <span class="ident">file</span>: <span class="ident">File</span>) <span class="op">-&gt;</span>  <span class="ident">String</span> { ... } <span class="comment">// C</span></pre></div>
<h1 id="moves-more-realistic-1" class="section-header"><a href="#moves-more-realistic-1">Moves, more realistic</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">open_file</span>(<span class="string">&quot;data/example.csv&quot;</span>);
    <span class="kw">let</span> (<span class="ident">headings</span>, <span class="ident">file2</span>) <span class="op">=</span> <span class="ident">read_line</span>(<span class="ident">file</span>); <span class="comment">// A</span>
    <span class="kw">let</span> (<span class="ident">data_line</span>, <span class="kw">_</span>) <span class="op">=</span> <span class="ident">read_line</span>(<span class="ident">file2</span>); <span class="comment">// B</span>
}

<span class="kw">fn</span> <span class="ident">open_file</span>(<span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="ident">File</span> { ... }

<span class="kw">fn</span> <span class="ident">read_line</span>(<span class="kw-2">mut</span> <span class="ident">file</span>: <span class="ident">File</span>) <span class="op">-&gt;</span> (<span class="ident">String</span>, <span class="ident">File</span>) { ... } <span class="comment">// C</span></pre></div>
<h1 id="mut-more-realistic" class="section-header"><a href="#mut-more-realistic"><code>&amp;mut</code>, more realistic</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">open_file</span>(<span class="string">&quot;data/example.csv&quot;</span>);
    <span class="kw">let</span>  <span class="ident">headings</span> <span class="op">=</span> <span class="ident">read_line</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">file</span>); <span class="comment">// A</span>
    <span class="kw">let</span>  <span class="ident">data_line</span> <span class="op">=</span> <span class="ident">read_line</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">file</span>); <span class="comment">// B</span>
}

<span class="kw">fn</span> <span class="ident">open_file</span>(<span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="ident">File</span> { ... }

<span class="kw">fn</span> <span class="ident">read_line</span>(<span class="ident">file</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">File</span>) <span class="op">-&gt;</span> <span class="ident">String</span> { ... } <span class="comment">// C</span></pre></div>
<h1 id="mut-1" class="section-header"><a href="#mut-1"><code>&amp;mut</code></a></h1>
<blockquote>
<p>pure functional programming is an ingenious trick to show you can
code without mutation, but Rust is an even cleverer trick to show
you can just have mutation. —
<a href="https://boats.gitlab.io/blog/post/notes-on-a-smaller-rust/">@withoutboats</a></p>
</blockquote>
<br>
<br>
<p>See also: <a href="http://smallcultfollowing.com/babysteps/blog/2018/02/01/in-rust-ordinary-vectors-are-values/">&quot;In Rust, ordinary vectors are
values&quot;</a>,
for mutable interfaces to persistent data structures.</p>
<h1 id="memory-c" class="section-header"><a href="#memory-c">Memory: C</a></h1><!--

In C, you might recall memory is managed via manual calls to `malloc`
to dynamically allocate a new chunk of memory and `free` to clean it
up, and mark that memory as not used. Here I've created a string of
1024 bytes, use it for a bit, and then `free` it. It looks like I've
been reasonably sensible and done it correctly, where all of the uses
are strictly between the create and clean-up.

However, if I got it wrong, or if `do_x` or `do_y` did something a bit
fancy, I would have problems. If I forgot to call `free`, I'd have a
memory leak, annoying but not too bad. If I used the pointer after
`free`ing, I'd have a problem that could lead to memory corruption and
security vulnerabilities. And, the same if I called `free` twice.

This is hard to get right in a complicated program.

-->

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// create</span>
<span class="ident">char</span> <span class="kw-2">*</span><span class="ident">pointer</span> <span class="op">=</span> <span class="ident">malloc</span>(<span class="number">1024</span>);

<span class="comment">// use</span>
<span class="ident">do_x</span>(<span class="ident">pointer</span>);
<span class="ident">do_y</span>(<span class="ident">pointer</span>);

<span class="comment">// clean-up</span>
<span class="ident">free</span>(<span class="ident">pointer</span>);</pre></div>
<p>Same problems:</p>
<ul>
<li>no clean-up: memory leak</li>
<li>use after clean-up: <strong>use-after-free vulnerability</strong></li>
<li>double clean-up: <strong>double-free vulnerability</strong></li>
</ul>
<h1 id="memory-garbage-collection" class="section-header"><a href="#memory-garbage-collection">Memory: Garbage Collection</a></h1><!--

We've seen consistently that having to clean up our resources can lead
to problem, so garbage collection or GCs remove the need to clean up
memory. This works great: without needing to call `free`, there's no
way to call it wrong. If a piece of memory is still accessible and so
may be used in future, it won't be cleaned up, so no use-after-free,
and, the GC itself is carefully implemented to only free things once
no double-free!

GCs have, and still do, serve as a great tool for avoiding the worst
memory corruption vulnerabilities. However, they only solve a subset
of memory leaks, and they don't help much with other types of resource
management.

-->
<p>Clean-up happens ✨magically✨</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// create</span>
<span class="ident">Something</span> <span class="ident">obj</span> <span class="op">=</span> <span class="ident">new</span> <span class="ident">Something</span>;

<span class="comment">// use</span>
<span class="ident">obj</span>.<span class="ident">do_x</span>()
<span class="ident">obj</span>.<span class="ident">do_y</span>()

<span class="comment">// stop using, and clean-up/free will eventually happen</span></pre></div>
<h1 id="memory-rust" class="section-header"><a href="#memory-rust">Memory: Rust</a></h1>
<p>Exactly the same as the file resource:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">split_headers</span>() {
    <span class="kw">let</span> <span class="ident">line</span>: <span class="ident">String</span> <span class="op">=</span> <span class="string">&quot;year,data&quot;</span>.<span class="ident">to_string</span>();

    <span class="ident">line</span>.<span class="ident">split</span>(<span class="string">&#39;,&#39;</span>)...
} <span class="comment">// end of scope, `line` is freed</span></pre></div>
<h1 id="collections-vectors" class="section-header"><a href="#collections-vectors">Collections: Vectors</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> { ... }

<span class="kw">let</span> <span class="ident">headings</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span> <span class="op">=</span> ...</pre></div>
<ul>
<li><code>&lt;...&gt;</code> denote generics</li>
<li><code>Vec&lt;T&gt;</code> = growable vector of an arbitrary type <code>T</code></li>
</ul>
<details>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">T</span>, <span class="comment">// pointer to allocation, with space for</span>
    <span class="ident">cap</span>: <span class="ident">usize</span>, <span class="comment">// values of type `T`, and the first</span>
    <span class="ident">len</span>: <span class="ident">usize</span>, <span class="comment">// instances are valid</span>
}</pre></div>
<p><img src="images/vec.png" alt="" /></p>
<p>— <a href="https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit#slide=id.p">Rust container cheat sheet</a></p>
</details>
<h1 id="collections-strings" class="section-header"><a href="#collections-strings">Collections: Strings</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">type</span> <span class="ident">String</span> <span class="op">=</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>; <span class="comment">// (almost)</span></pre></div>
<ul>
<li>growable vector of bytes</li>
<li>always valid UTF-8</li>
</ul>
<h1 id="basics-if" class="section-header"><a href="#basics-if">Basics: <code>if</code></a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">if</span> <span class="ident">foo</span>(<span class="ident">bar</span>) {
    <span class="ident">something</span>()
} <span class="kw">else</span> <span class="kw">if</span> <span class="ident">baz</span> <span class="op">==</span> <span class="ident">qux</span> {
    <span class="ident">another_thing</span>()
} <span class="kw">else</span> {
    <span class="ident">third_thing</span>()
}</pre></div>
<h1 id="basics-for" class="section-header"><a href="#basics-for">Basics: <code>for</code></a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">for</span> <span class="ident">index</span> <span class="kw">in</span> <span class="ident">iterator</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;index = {}&quot;</span>, <span class="ident">index</span>);
}</pre></div>
<h1 id="basics-while" class="section-header"><a href="#basics-while">Basics: <code>while</code></a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">while</span> <span class="ident">condition</span> {
    <span class="ident">something</span>()
}</pre></div>
<h1 id="extensions" class="section-header"><a href="#extensions">Extensions</a></h1>
<ul>
<li>parallelism: <a href="https://docs.rs/rayon">docs.rs/rayon</a></li>
<li>property testing: <a href="https://docs.rs/proptest">docs.rs/proptest</a></li>
<li>fuzzing: <a href="https://github.com/rust-fuzz/cargo-fuzz/">github.com/rust-fuzz/cargo-fuzz</a></li>
</ul>

    
</body>
</html>